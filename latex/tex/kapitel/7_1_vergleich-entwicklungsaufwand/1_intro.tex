\chapter{Vergleich des Entwicklungsaufwands}

Das folgende Kapitel vergleicht \ac{AWS} Amplify mit Firebase anhand der entwickelten Plattformen. Dabei liegt der Fokus des Vergleichs auf dem Entwicklungsaufwand.

\section{Vergleichskategorien}

Verglichen werden der Entwicklungsprozess sowie die Ebenen Infrastruktur, Backend und Frontend.

\subsection{Entwicklungsprozess}

Für die lokale Entwicklung bietet \ac{AWS} Amplify die Möglichkeit, \ac{AWS} AppSync und Lambda sowie Amazon DynamoDB und S3 lokal zu betreiben und zu testen. Dies beschleunigt die lokale Entwicklung, da Änderungen nicht zwangsläufig sofort in die Cloud hochgeladen werden müssen, was eine Wartezeit von einigen Minuten bei diesem Projekt bedeutet. Mit dem Feature \textit{Emulator} bietet auch Firebase eine solche Möglichkeit an. Damit lassen sich die Dienste Storage, Auth, Firestore, Functions und Hosting für dieses Projekt lokal betreiben. Im Gegensatz zu \ac{AWS} Amplify werden damit noch zusätzlich die Bereiche Authentifizierung und Hosting des Frontends abgedeckt. Obwohl diese Bereiche zusätzlich abgedeckt sind, ergibt sich kein zeitlicher Vorteil für Firebase. Ohnehin lässt sich das Frontend lokal starten und die Konfiguration der Authentifizierung ändert sich nur in den seltensten Fällen.

Ein weiterer Vergleichspunkt ist das Deployment der Anwendungen. Während \ac{AWS} Amplify eine integrierte CI/CD-Pipeline mittels \ac{AWS} CodeBuild anbietet, muss in Firebase auf eine eigenen Pipeline, zum Beispiel über GitHub Actions, zurückgegriffen werden. Dieses bedeutet zusätzlichen Aufwand beim Setup der Entwicklungsumgebung. Jedoch existiert für die fehlende integrierte Pipeline von Firebase eine vordefinierte Datei für GitHub Actions, was den Aufwand sehr gering hält. Auf der anderen Seite basiert das Deployment von \ac{AWS} Amplify auf CloudFormation-Templates. Auf Grund der Komplexität dieses Vorgehens, passieren hier mehr Fehler, als wenn es diese nicht gibt.

Daher ist zusammenfassend der Entwicklungsprozess von Firebase schneller, da die Komplexität geringer ist und Entwickler weniger Fehler machen können.

\subsection{Infrastruktur}

Für Änderungen an der Infrastruktur werden bei \ac{AWS} CloudFormation-Templates genutzt. Dadurch lassen sich die meisten Ressourcen von \ac{AWS} abbilden. In diesem Projekt sind das zum Beispiel ein MediaConvert Job Template oder eine EventBridge Regel. Einige Anpassungen an von Amplify bereitgestellten Ressourcen lassen sich im CloudFormation-Template allerdings nicht verändern. Der Build-Prozess überschreibt die Veränderung, so dass beispielsweise das folgende Szenario nicht möglich ist:

Im \textit{AuthStack} muss die Identifikation des User-Pools statt die des Identity-Pools genutzt werden, damit die enstprechende Lambda-Funktion die Information erhält, um welchen Nutzer es sich handelt. Als Workaround muss die Änderung manuell in die Cognito-Ressource eingetragen werden. Das ist sehr fehleranfällig, da bei einem erneuten Setup des Projektes die manuelle Änderung immer wieder eingespielt werden muss. Dies ist nur ein Beispiel von vielen Herausforderungen, die dabei auftreten können.

Damit ist \ac{AWS} Amplify zwar sehr mächtig, wenn es darum geht, Dienste hinzuzufügen, welche nicht in Amplify vorkonfiguriert sind, allerdings ist es problematisch bestehende Dienste beliebig anzupassen.

Dagegen ergibt sich die Infrastruktur in Firebase direkt aus dem Code und es sind keine weiteren Definitionen wie in \ac{AWS} Amplify nötig. Das ist zunächst einmal weniger zeitaufwendig für den Entwickler. Hingegen kommt durch die geringere  Komplexität der Nachteil, dass Infrastrukturen nicht beliebig konfiguriert werden können.

Zusammenfassend ist \ac{AWS} Amplify damit komplexer und umfangreicher und damit langsamer zu entwickeln. Mit Firebase lässt sich zwar nicht jedes beliebige Cloud-Setup abbilden, jedoch ist die Entwicklungszeit damit auch schneller.

\subsection{Backend}

Auch im Backend unterscheidet sich die Entwicklung. \ac{AWS} Amplify nutzt mit AppSync eine GraphQL-Schnittstelle, während Firebase darauf verzichtet. Für ein Projekt dieser Größe und auf Grund der Tatsache, dass die Schnittstelle nur sehr wenige Routen anbietet, ist dies kein Risiko für das Projekt, sondern eine sinnvolle Zeiteinsparung.

Auf der anderen Seite kann \ac{AWS} AppSync über die VTL-Resolver Routen, welche keine zusätzliche Logik benötigen, ohne Code zu DynamoDB abbilden. Die Zugriffskontrollen werden über das GraphQL-Schema definiert. Dies verringert die Entwicklungszeit von \ac{AWS} Amplify. Wird jedoch dennoch zusätzlicher Code für eine Route benötigt, muss eine Lambda-Funktion inklusive der benötigten Berechtigungen erstellt werden. Dies tritt im Projekt mehrmals auf und kostet daher mehr Zeit, als in Firebase. In Firebase ist die Infrastruktur direkt im Code, was es die Definition einer Funktion deutlich vereinfacht.

Weiterhin ist zu erwähnen, dass Amazon Cognito ein Gruppenkonzept anbietet, welches nahtlos mit \ac{AWS} AppSync und Amplify integriert. Dies ist in Firebase nicht der Fall, so dass die Anforderungen, verschiedene Gruppen wie Administratoren abzubilden, bei Firebase selbst programmiert werden muss.

Ein weiterer Vergleichspunkt ist die Videokonvertierung. Hieran lässt sich wieder erkennen, dass die \ac{AWS}-Cloud komplexer ist. Während bei Firebase ein einziger API-Aufruf zur Transcoder-API reicht, müssen bei /ac{AWS} mehrere Infrastruktur-Elemente erstellt werden. Zum einen wird eine Lambda-Funktion für den eigentlichen Aufruf benötigt. Dann wird ein MediaConvert Job-Template benötigt. Eine weitere EventBridge-Regel und eine zusätzliche Lambda-Funktion werden benötigt, um über die erfolgreiche Transkodierung benachrichtigt zu werden. Das macht es möglich, komplexere Architekturen abzubilden, jedoch erhöht dies gleichzeitig die Entwicklungszeit.

Alles in allem ist damit die Entwicklungszeit für beide Dienste schon sehr gering, da es wenig Boilerplate-Code gibt, jedoch ist die Entwicklung in Firebase nochmal schneller, da die Architektur einfach gehalten werden kann.

\subsection{Frontend}

GraphQL
- funktionen callen vs app sync

\section{Zusammenfassung}

TODO: - Amplify generell komplexer als Firebase, Setup war schwerer, mehr Fehler, Firebase war einfacher

\autoref{tab:entwicklungszeit} visualisiert die Ergebnisse des Vergleichs.

TODO: noch granularer aufzeigen

\begin{table}[h]
  \caption{Vergleich der Entwicklungszeit}
  \label{tab:entwicklungszeit}
  \centering
  \begin{tabular}{lccc}
    \toprule
    & \ac{AWS} Amplify 1 & Firebase 2\\
    \midrule
    Entwicklungsprozess	& \harveyBallThreeQuarter & \harveyBallFull \\
    Infrastruktur	& \harveyBallHalf & \harveyBallFull \\
    Backend	& \harveyBallThreeQuarter & \harveyBallFull \\
    Frontend	& \harveyBallThreeQuarter & \harveyBallThreeQuarter \\
    \bottomrule
  \end{tabular}
\end{table}