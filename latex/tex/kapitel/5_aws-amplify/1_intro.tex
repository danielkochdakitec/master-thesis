\chapter{AWS Amplify}

Das folgende Kapitel beschreibt die Architektur und die Implementierung mit Amplify.

\section{Architektur}

todo

\subsection{Lösungsstrategie}

Die Architektur folgt dem Aufbau einer Drei"=Schichten"=Architektur:
\begin{itemize}
  \item Präsentationsschicht
    \begin{itemize}
      \item React.js
      \item amplify-js
    \end{itemize}
  \item Logikschicht
    \begin{itemize}
      \item AppSync
      \item Lambda
      \item Cognito
      \item Elemental MediaConvert
      \item EventBridge
      \item IAM
    \end{itemize}
  \item Datenhaltungsschicht
    \begin{itemize}
      \item DynamoDB
      \item S3
      \item Cognito
      \item IAM
      \item AWS Backup
    \end{itemize}
\end{itemize}

Die Dienste Cognito und IAM befindet sich zugleich in zwei Schichten, da dort neben der Logik für Authentifizierung und Autorisierung auch die Benutzer persistiert werden.

Durch die ausschließliche Verwendung interner Dienste von \ac{AWS}, keiner Eigenentwicklungen für die Benutzerverwaltung und den vorgegebenen Technologien sind die Rahmenbedingungen für dieses Projekt nicht missachtet, so dass die beiden Technologien weiterhin vergleichbar sind.

\autoref{Kap2:NFAs} zeigt Lösungsansätze, um die nichtfunktionalen Anforderungen, auch Qualitätsziele genannt, zu erreichen.

\begin{table}[h]
  \caption{Lösungsansatz für nichtfunktionale Anforderungen}
  \label{Kap2:NFAs}
  \renewcommand{\arraystretch}{1.2}
  \centering
  \sffamily
  \begin{footnotesize}
    \begin{tabularx}{0.9\textwidth}{l l X}
      \toprule
      \textbf{Anforderung} & \textbf{Dienst} & \textbf{Ansatz}\\
      \midrule
        \emph{Verfügbarkeit} & Amplify & Amplify bietet für Frontend und Backend ein Zero-Downtime Deployment. \\
        \emph{Skalierbarkeit} & - & Durch die Serverless-Architektur skalieren Dienste automatisch innerhalb der \ac{AWS}-Cloud.\\
        \emph{Analysierbarkeit} & CloudWatch & Durch den Einsatz von CloudWatch können Anfragen für jeden Dienst nachvollzogen werden.\\
        \emph{Interoperabilität} & AppSync & Durch den Einsatz von AppSync ist mit GraphQL eine einheitliche Schnittstelle sichergestellt.\\
        \emph{Backups} & AWS Backup & Durch den Einsatz von AWS Backup werden automatisiert Backups aufgesetzt.\\
        \emph{Wiederherstellbarkeit} & AWS Backup &  Das von AWS Backup erstellte Backup für die Datenbank DynamoDB kann manuell eingespielt werden.\\
      \bottomrule
    \end{tabularx}
  \end{footnotesize}
  \rmfamily
\end{table}

\subsection{Bausteinsicht}

Die Architektur ist unterteilt in Frontend (Präsentationsschicht) und Backend (Logik- und Datenhaltungsschicht). Das Frontend wird nicht näher beschrieben, da Amplify dieses vollständig verwaltet. Das Backend besteht aus Stacks, welche zugleich den Code als auch die Infrastruktur repräsentieren. Diese werden im folgenden Abschnitt dargestellt:
\begin{itemize}
  \item{Der \textit{RootStack} enthält alle darunterliegenden Stacks sowie Ressourcen zum Deployment von Amplify.}

  \item{Der \textit{ApiStack} besteht aus den Diensten AppSync und DynamoDB. AppSync besteht aus einer GraphQLApi, die ein GraphQLSchema enthält. Außerdem nutzt AppSync Resolver, um ein Mapping über VTL zur DynamoDB-Tabelle zu ermöglichen. Um eine Verbindung zu einer Lambda-Funktion zu ermöglichen, existiert auch mindestens eine DataSource.}

  \item{Der \textit{AuthStack} regelt die Authentifizierung und Autorisierung von Benutzern über den Dienst Cognito. Dieser besteht aus einem UserPool und einem IdentityPool und den entsprechenden IAM-Rollen und Policies. Des weiteren besteht der Stack aus einem UserPoolClient, über welchen Anfragen auf Cognito erfolgen können. Amplify definiert auch weitere Lambda-Funktionen, um zusätzliche Logik für die Authentifizierung zu ermöglichen.}

  \item{Der \textit{AuthUserPoolGroupStack} dient zur Verwaltung der zusätzlichen UserPoolGroup für Administratoren.}

  \item{Der \textit{StorageStack} dient zur Speicherung der Videos. Dieser enthält einen S3-Bucket sowie eine dazugehören Policy, welchen es Benutzern ermöglicht, Dateien in eigene Ordner hochzuladen sowie andere Ordner lesen zu dürfen. Die Policy unterscheidet zwischen öffentlichen, geschützten und privaten Geltungsbereichen.}

  \item{Der \textit{FunctionLayerStack} bündelt die Node.js-Module als Lambda-Layer, den die weiteren Lambda-Funktionen nutzen.}

  \item{Der \textit{FunctionCreateVideoStack} übernimmt die Erstellung eines Videos in Form einer Lambda-Funktion. Außerdem erstellt der Stack in MediaConvert ein JobTemplate und eine Queue. Des Weiteren definiert der Stack die nötige Policy und Rolle, um der Lambda-Funktion die Zugriffe auf andere Dienste zu ermöglichen.}

  \item{Der \textit{FunctionVideoConvertedStack} besteht aus einer EventBridge-Regel, die bei einer Konvertierung eines Videos aufgerufen wird. Außerdem wird eine Lambda-Funktion mit der nötigen Policy und Rolle erstellt.}

  \item{Der \textit{FunctionCreateLinkStack} besteht aus einer Lambda-Funktion und der nötigen Rolle und Policy, um einen signierten zeitlich begrenzt gültigen Video-Link zu erstellen.}
\end{itemize}

Die Stacks \textit{RootStack}, \textit{ApiStack}, \textit{AuthStack}, \textit{AuthUserPoolGroupStack} und \textit{StorageStack} erstellt Amplify selbst. Die restlichen Stacks sind selbst erstellte bzw. angepasste Plugins, da die Dienste nicht vollständig in Amplify vorhanden sind.

\subsection{Laufzeitsicht}

Die Laufzeitsicht beschreibt die wichtigsten Prozesse und wie die Bausteine miteinander interagieren.

\subsubsection{Lesen, Aktualisieren und Löschen eines Videos}

\begin{figure}
  \centering
  \includegraphics[width=0.75\columnwidth]{5_aws-amplify/laufzeitsicht_1.pdf}
  \caption{AWS Amplify - Laufzeitsicht - Lesen, Aktualisieren und Löschen eines Videos}
  \label{Amplify:laufzeitsicht1}
\end{figure}

\autoref{Amplify:laufzeitsicht1} stellt den Prozess dar, wie Videos von Nutzern gelesen, aktualisiert oder gelöscht werden. Dieser wird im folgenden Abschnitt näher erläutert:
\begin{enumerate}
  \item{Der Nutzer stellt eine Anfrage mittels GraphQL und dem JSON Webtoken.}
  \item{AppSync autorisiert den Nutzer und holt die Gruppenzugehörigkeit des Nutzers.}
  \item{Der Resolver leitet die Anfrage unter Berücksichtigung der Gruppenzugehörigkeit des Nutzers an DynamoDB weiter. Die nötigen Datenbankoperationen werden über DynamoDB ausgeführt.}
\end{enumerate}

Zusätzlich dazu müssen signierte temporäre Links erstellt werden, um die Sicherheit zu gewährleisten. Dieser Ablauf, der in \autoref{Amplify:laufzeitsicht2} dargestellt wird, enthält noch eine zusätzlich Abfrage auf S3, um den Link zu erstellen.

\begin{figure}
  \centering
  \includegraphics[width=1\columnwidth]{5_aws-amplify/laufzeitsicht_3.pdf}
  \caption{AWS Amplify - Laufzeitsicht - Erstellen von Links}
  \label{Amplify:laufzeitsicht2}
\end{figure}

\subsubsection{Erstellen eines Videos}

\autoref{Amplify:laufzeitsicht3} stellt den Prozess dar, wie ein Video erstellt wird.
\begin{enumerate}
  \item{Zunächst lädt der Nutzer das Video in den S3-Bucket hoch. Die Policy des S3-Buckets verwaltet den korrekten Zugriff auf die Ressource. Die hochgeladene Datei landet in einem privaten Ordner, der außerhalb des Backends ausschließlich für den Besitzer des Objekts aufrufbar ist. Das ist der Nutzer, der das Video hochgeladen hat.}
  \item{Erst dann erstellt der Nutzer eine Anfrage mittels GraphQL und dem JSON Webtoken.}
  \item{AppSync autorisiert den Nutzer und holt die Gruppenzugehörigkeit des Nutzers.}
  \item{Der Resolver führt die verknüpfte Lambda-Funktion aus.}
  \item{Die Funktion kopiert die hochgeladene Datei in einen weiteren Ordner, so dass der Besitzer diese nicht mehr verändern kann. Die hochgeladene Datei im Ursprungsordner wird daraufhin gelöscht.}
  \item{Die Funktion erstellt das Video in der DynamoDB-Tabelle.}
  \item{Die Funktion führt den MediaConvert-Job aus, um das Video mit dem Wasserzeichen zu versehen.}
  \item{Ist die Konvertierung abgeschlossen, benachrichtigt die EventBridge eine weitere Lambda-Funktion, welche das Video dann freischaltet.}
\end{enumerate}

\begin{figure}
  \centering
  \includegraphics[width=1\columnwidth]{5_aws-amplify/laufzeitsicht_2.pdf}
  \caption{AWS Amplify - Laufzeitsicht - Erstellen eines Videos}
  \label{Amplify:laufzeitsicht3}
\end{figure}

\subsection{Verteilungssicht}

Die Verteilungssicht beschreibt, wie die Bausteine in \ac{AWS} über Stacks verteilt werden. Amplify bündelt die Verteilung des Backends und des Frontends über eine Pipeline. Diesen Sachverhalt stellt \autoref{Amplify:verteilungssicht} dar.

\begin{figure}
  \centering
  \includegraphics[width=0.75\columnwidth]{5_aws-amplify/verteilungssicht.pdf}
  \caption{AWS Amplify - Verteilungssicht}
  \label{Amplify:verteilungssicht}
\end{figure}

Amplify verteilt das Backend über die CloudFormation mittels Stacks. Außerdem werden nur Stacks und keine NestedStacks genutzt, was die Fehleranalyse vereinfacht. Um eine neue Änderung in das System einzuspielen, erzeugt die CloudFormation ein ChangeSet, welches die Differenz aus dem aktuellen Stand in der Cloud und dem gewünschten Zielzustand ist. Wenn beim Aktualisieren der Stacks ein Fehler auftritt, erfolgt ein Rollback.

Das Frontend wird separat, also nicht über Stacks, verteilt. Dazu nutzt Amplify einen gebündelten Dienst, der über die CloudFront läuft. Letzterer kann allerdings als Black-Box betrachtet werden, da der Entwickler diesen nur durch die Konfiguration beeinflussen kann.

\subsection{Querschnittliche Konzepte und Muster}

Logging
- CloudWatch

Backup
- AWS Backup

- Einbindung über \ac{AWS} Amplify:
  - AWS Elemental MediaConvert als extra Plugin
  - Anpassung an CF-Templates
- Permissions (IAM)

\subsection{Entwurfsentscheidungen}

\subsection{Risiken und technische Schulden}

- Auth: Anpassung, dass statt Identity ID die Pool User Id genutzt wird geht über https://github.com/aws-amplify/amplify-js/issues/54. Leider lässt sich das nicht persistieren, so dass man das bei jedem branch/Projekt neu eintragen muss. Wenn man es im CF-Template ändert, wird die Änderung beim Push rückgängig gemacht. Das ist nicht sehr flexibel. Ggf. Lösung finden und schauen, ob es doch geht.

- CDK als Alternative zu AWS Amplify, da es wesentlich flexibler

\section{Implementierung}